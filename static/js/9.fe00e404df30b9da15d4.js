webpackJsonp([9],{Zwsn:function(n,o){n.exports="# JavaScript模块化机制分析\n## AMD,CMD,UMD  \n`AMD`翻译为异步模块定义，在加载模块以及其他模块时，采用异步加载方式，避免模块加载阻塞网页渲染进度。  \n`CMD`同样为异步模块定义规范，两者的区别主要在于:`AMD`推崇依赖前置，提前执行，`CMD`推崇就近依赖，延迟执行。  \n\n```javascript\n//AMD加载运行方式\ndefine(['./a','./b'], function (a, b) {\n\n    //依赖一开始就写好，相对于自定义模块函数，AMD提前执行所有依赖\n    a.test();\n    b.test();\n});\n//CMD加载运行方式\ndefine(function (requie, exports, module) {\n\n    //依赖就近书写\n    var a = require('./a');\n    a.test();\n});\n```\n\n`UMD`通用模块定义，是`AMD`和`CommonJS`的糅合，基本原理为先判断是否支持`node.js`模块，再判断是否支持`AMD`。  \n\n## es6中import方式\n`ES6`模块加载方式与`CommonJS`的主要区别在于:  \n1.`CommonJS`模块输出为值的拷贝，`ES6`输出为值的引用。  \n2.`CommonJS`模块是运行时加载，`ES6`模块是编译时输出接口。  \n\n即，`CommonJS`加载模块后，模块的内部变化不会影响对外的输出值，但是可以通过exports一个函数出来，获取内部变化。  \n\n而`ES6`模块的运行机制为，遇到`import`生成一个只读引用。等待真正执行时，再去模块取值，因此，`ES6`的模块时动态引用。\n\n```javascript\n// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n\n// main.js\nimport { counter, incCounter } from './lib';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n```\n*PS:CommonJS会对值进行缓存，ES6的不会*\n"}});
//# sourceMappingURL=9.fe00e404df30b9da15d4.js.map