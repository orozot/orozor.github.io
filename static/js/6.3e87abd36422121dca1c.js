webpackJsonp([6],{aeud:function(n,o){n.exports="{\n  \"title\": \"原型和原型链详解\",\n  \"date\": \"2018-02-22\",\n  \"tags\": \"javascript\"\n}\n\n## 私有变量和函数\n\n在函数内部定义的变量和函数，如果不对外提供接口，外部是无法访问到的，也就是该函数的`私有变量`和`私有函数`。\n\n```javascript\nfunction Person() {\n  const name = 18;\n  const say = function() {\n    console.log('hello world');\n  }\n}\n\nconst person = new Person();\nperson.name; // undefined\nperson.say; // undefined\n```\n\n## 静态变量和函数\n\n当定义一个函数后通过点号 `'.'`为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为`静态变量`和`静态函数`。\n\n```javascript\nfunction Person() {};\n\nPerson.age = 18;\nPerson.say = function() {\n  console.log(`hello world`);\n}\n\nPerson.age; // 18\ntypeof Person.say; // function\n\nconst person = new Person();\nperson.age; // undefined\nperson.say; // undefined\n\n```\n\x3c!-- lph --\x3e\n## 实例变量和函数\n\n实例可以访问的变量和函数\n\n```javascript\nfunction Person() {\n  this.name = 'John';\n  this.walk = function() {\n    console.log('walking');\n  };\n}\n\nconst p1 = new Person();\np1.name; // 'John'\np1.walk(); // 'walking'\n\n// 接下来\nconst p2 = new Person();\np1.walk === p2.walk; // false\n```\n\n上面的`p1.walk === p2.walk; // false`可以看出，`p1`和`p2`的`walk`函数名相同,，做完全一样的功能，却不是同一个引用。\n\n如果一个函数有千万个实例，那么每个实例的方法就要保持一千万份的复制，这显然太浪费资源了。\n\n`prototype`应运而生。\n\n## 基本概念\n\n每个构造函数（对象）都有一个`prototype`属性，这是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。\n\n每个构造函数都有一个内部属性`prototype`属性，我们称之为`原型` 。\n\n实例不具备`prototype`属性，而是用`__proto__`指向原型。\n\n下面是原型对象的结构：\n\n```javascript\nPerson.prototype = {\n  constructor : Function, // 构造函数\n  __proto__ : parent prototype, // 指向上一层的原型对象\n  some prototype properties: ... // 共享的对象和方法\n};\n```\n\n接下来看个原型实例：\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.say = function() {\n  console.log(`hello ${this.name}`);\n}\n\nconst p = new Person('John');\n\np.say(); // 'hello John'\n```\n\n当我们调用`p.say()`方法时，由于`Person`中没有这个方法，所以，它就会去`__proto__`中找，也就是`Person.prototype`。\n\n* `prototype`和`__proto__`的关系：\n\n ![prototype](http://note.youdao.com/yws/api/personal/file/D8B6646E2F1F4650988AD6F867D5F39D?method=download&shareKey=4f83ebac192d6d74f5f3fb719caeb535)\n\n实例一旦创造出来，就具有`contructor`（指向构造函数）和`__proto__`（指向原型对象）。\n\n构造函数中也有一个`prototype`属性，是一个指针，指向它的原型对象。\n\n如上图，我们可以得出下面的关系：\n\n```javascript\nfunction Person() {\n  this.name = 'John';\n}\n\nPerson.prototype.say = function() {\n  console.log('hello world');\n}\nconst p1 = new Person();\nconst p2 = new Person();\n\nPerson.prototyp.say === p1.say === p2.say; // true\nPerson.prototype === p1.__proto__ === p2.__proto__; // true\nPerson.prototype.constructor === p1.constructor ==== p2.constructor === Person; // true\n```\n\n事实上，`new`就做了三件事：\n\n```javascript\nvar obj  = {};  \nobj.__proto__ = Base.prototype;  \nBase.call(obj);\n```\n\n## 原型链\n\n当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会自己指向的的`prototype`原型对象寻找，如果没有，就会去`prototype`关联的上层`prototype`寻找，如果再没有则继续查找，依次类推，直到为`prototype`为`null`从而形成了所谓的原型链。\n\n* 原型继承\n\n  在原型链的末端，就是`Object`构造函数`prototype`属性指向的那个原型对象。它是所有对象的祖先，实现了诸如`toString `的对象天生就有的方法。\n\n  `ECMAScript`中，实现继承的方法就是依靠原型链实现的。\n\n```javascript\nfunction Father() {\n  this.name = 'John';\n  \n  this.walk = function() {\n    console.log('walking');\n  }\n}\n\nFather.prototype.say = function() {\n  console.log('I\\'m Father');\n}\n\nfunction Son() {\n  this.age = 18;\n}\n\nSon.prototype = new Father();\n\nconst s1 = new Son();\nconst s2 = new Son();\n\ns1.name; // 'John'\ns1.say(); // 'I'm Father'\ns1.walk(); // 'walkding'\n\ns1.walk === s2.walk; // true\n```\n\n`Father`的实例属性也就变成`Son`原型的属性，而`Son.prototype.__proto__ === Father.prototype` 。\n\n## 参考\n\n1. https://segmentfault.com/a/1190000000662547#articleHeader6\n2. http://www.jianshu.com/p/aa1ebfdad661\n\n"}});
//# sourceMappingURL=6.3e87abd36422121dca1c.js.map